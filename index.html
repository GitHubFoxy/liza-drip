<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>@lisarang</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Playfair+Display:wght@500;600;700&display=swap"
      rel="stylesheet"
    />

    <!-- Tailwind (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
      /* --- Page background: off-white + subtle grid overlay --- */
      :root {
        --bg: #f3f3f3;
        --grid: rgba(0, 0, 0, 0.04);
      }

      html,
      body {
        height: 100%;
      }

      body {
        background: var(--bg);
        /* Two layered linear-gradients create a faint grid */
        background-image: linear-gradient(to right, var(--grid) 1px, transparent 1px),
          linear-gradient(to bottom, var(--grid) 1px, transparent 1px);
        background-size: 56px 56px;
        background-position: center;
      }

      /* Font helpers (so we can use Tailwind for most styling) */
      .font-serif {
        font-family: "Playfair Display", ui-serif, Georgia, Cambria, "Times New Roman",
          Times, serif;
      }

      .font-ui {
        font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      }

      /* --- Flashlight mask rendering ---
         We reveal the "fun" image by applying a circular clip-path that follows the mouse.
         The value is updated from JS (with lerp) via CSS variables.
      */
      .reveal {
        /* defaults (hidden until interaction) */
        --x: 50%;
        --y: 50%;
        --r: 0px;

        clip-path: circle(var(--r) at var(--x) var(--y));
        -webkit-clip-path: circle(var(--r) at var(--x) var(--y));
        will-change: clip-path;
      }

      /* Optional: custom cursor inside the image area */
      .image-stage {
        cursor: none;
        touch-action: none; /* prevents scroll/pinch gestures from interrupting lens tracking */
      }

      /* The visible custom cursor ring */
      .cursor-lens {
        position: absolute;
        left: 0;
        top: 0;
        width: calc(var(--r) * 2);
        height: calc(var(--r) * 2);
        transform: translate(-50%, -50%);
        border-radius: 9999px;
        border: 1px solid rgba(0, 0, 0, 0.35);
        box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.35) inset;
        pointer-events: none;
        opacity: 0;
        transition: opacity 160ms ease;
        will-change: left, top, opacity;
      }

      /* Show lens only while hovering with a mouse, or while actively touching/dragging */
      /* Mouse hover shows lens; touch only shows while active (data-active=true) */
      .image-stage:hover .cursor-lens,
      .image-stage:focus-within .cursor-lens,
      .image-stage[data-active="true"] .cursor-lens {
        opacity: 1;
      }

      /* On coarse pointers (phones), don't show lens unless actively touching */
      @media (pointer: coarse) {
        .image-stage:hover .cursor-lens,
        .image-stage:focus-within .cursor-lens {
          opacity: 0;
        }
      }

      /* Make images crisp in their container */
      .image-stage img {
        user-select: none;
        -webkit-user-drag: none;
        pointer-events: none; /* ensure the stage receives pointer events; images are unclickable */
      }
    </style>

    <script>
      // Tailwind config (optional small tweaks)
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              ink: "#0b0b0c",
            },
          },
        },
      };
    </script>
  </head>

  <body class="font-ui text-ink antialiased">
    <a class="sr-only focus:not-sr-only focus:fixed focus:top-4 focus:left-4 focus:z-50 focus:rounded-md focus:bg-white focus:px-3 focus:py-2 focus:shadow" href="#main">
      Skip to content
    </a>

    <header class="fixed inset-x-0 top-0 z-20">
      <div class="mx-auto max-w-6xl px-6 pt-6">
        <div class="flex items-start justify-between">
          <!-- Top-left: Name -->
          <h1 class="font-serif leading-[0.95] tracking-tight">
            <span class="block text-5xl sm:text-6xl md:text-7xl">@lisarang</span>
          </h1>

          <!-- Top-right: (intentionally empty) -->
          <div class="pt-2"></div>
        </div>
      </div>
    </header>

    <main id="main" class="h-dvh overflow-hidden">
      <!-- Centered image area -->
      <section class="grid h-dvh place-items-center px-6">
        <figure
          id="imageStage"
          class="image-stage relative w-[min(78vw,440px)] aspect-[3/4] overflow-hidden rounded-2xl bg-white/40 shadow-[0_18px_40px_rgba(0,0,0,0.10)] ring-1 ring-black/10"
          aria-label="Liza portrait: move cursor to reveal a fun version"
          data-active="false"
        >
          <!-- Normal image (default visible) -->
          <img
            src="before.jpg"
            alt="Liza portrait (normal)"
            class="absolute inset-0 h-full w-full object-cover"
            draggable="false"
          />

          <!-- Fun image (revealed via circular clip-path mask) -->
          <img
            id="funImage"
            src="after.png"
            alt="Liza portrait (fun)"
            class="reveal absolute inset-0 h-full w-full object-cover"
            draggable="false"
          />

          <!-- Custom cursor ring -->
          <div id="cursorLens" class="cursor-lens" aria-hidden="true"></div>

          <!-- Helper text for touch devices -->
          <figcaption class="pointer-events-none absolute bottom-3 left-3 right-3 text-[11px] tracking-wide text-black/55">
            <span class="inline-block rounded-full bg-white/55 px-3 py-1 ring-1 ring-black/10 backdrop-blur">Move cursor to reveal</span>
          </figcaption>
        </figure>
      </section>

    </main>

    <!-- Bottom-right: Social icons -->
    <footer class="fixed inset-x-0 bottom-0 z-20">
      <div class="mx-auto max-w-6xl px-6 pb-6">
        <div class="flex items-end justify-end">
          <div class="flex items-center gap-3">
            <!-- Telegram -->
            <a
              href="https://t.me/lisarang"
              target="_blank"
              rel="noreferrer"
              aria-label="Telegram @lisarang"
              class="inline-flex h-10 items-center justify-center gap-2 rounded-full bg-white/55 px-4 ring-1 ring-black/10 backdrop-blur hover:bg-white/80 focus:outline-none focus:ring-2 focus:ring-black/40"
            >
              <svg viewBox="0 0 24 24" class="h-5 w-5 fill-black/80" aria-hidden="true">
                <!-- Minimal Telegram paper plane -->
                <path
                  d="M21.9 4.6c.2-.8-.6-1.5-1.4-1.2L2.6 10.3c-.9.3-.9 1.6.1 1.9l4.9 1.5 1.8 5.6c.3.9 1.5 1 2 .2l2.7-4.1 4.7 3.5c.7.5 1.7.1 1.9-.8L21.9 4.6ZM8.4 12.9l9.9-6.1-8.4 7.6-.3 3.9-1.4-4.4-3.3-1 13.5-5.2-10 5.2Z"
                />
              </svg>
              <span class="text-xs font-medium tracking-[0.18em] text-black/70">@LISARANG</span>
            </a>
          </div>
        </div>
      </div>
    </footer>

    <script>
      /**
       * Flashlight cursor reveal
       * - Two perfectly-aligned images are stacked.
       * - The top image (fun) is clipped with a circular clip-path.
       * - Mouse position is tracked inside the image container.
       * - We lerp current mask position toward target to create smooth trailing.
       */
      (() => {
        const stage = document.getElementById("imageStage");
        const funImage = document.getElementById("funImage");
        const lens = document.getElementById("cursorLens");

        // Configuration
        const radiusPx = 112; // lens radius
        const lerpFactorMouse = 0.34; // bigger = snappier tracking
        const lerpFactorTouch = 0.18; // a bit smoother to hide touch jitter

        // State
        let rafId = null;
        let active = false;
        let lerpFactor = lerpFactorMouse;

        // Target position (where the mouse is)
        let tx = 0;
        let ty = 0;

        // Current position (where the mask actually is)
        let cx = 0;
        let cy = 0;

        // Initialize CSS radius
        // - stage: used by the visible cursor ring size
        // - funImage: starts hidden (radius 0) until user interacts
        stage.style.setProperty("--r", `${radiusPx}px`);
        funImage.style.setProperty("--r", `0px`);

        // Utility: lerp
        const lerp = (a, b, t) => a + (b - a) * t;

        function setTargetFromEvent(e) {
          // Mouse should feel immediate; touch benefits from a little smoothing.
          lerpFactor = e.pointerType === "mouse" ? lerpFactorMouse : lerpFactorTouch;

          const rect = stage.getBoundingClientRect();
          tx = e.clientX - rect.left;
          ty = e.clientY - rect.top;

          // Clamp within bounds
          tx = Math.max(0, Math.min(rect.width, tx));
          ty = Math.max(0, Math.min(rect.height, ty));
        }

        function render() {
          // Smoothly move current position toward target
          cx = lerp(cx, tx, lerpFactor);
          cy = lerp(cy, ty, lerpFactor);

          // Update clip-path coordinates using px for accuracy
          funImage.style.setProperty("--x", `${cx}px`);
          funImage.style.setProperty("--y", `${cy}px`);

          // Update the visible custom cursor ring
          lens.style.left = `${cx}px`;
          lens.style.top = `${cy}px`;

          // Continue animating while active (or while settling)
          if (active || Math.abs(cx - tx) + Math.abs(cy - ty) > 0.2) {
            rafId = requestAnimationFrame(render);
          } else {
            rafId = null;
          }
        }

        function start() {
          if (rafId) return;
          rafId = requestAnimationFrame(render);
        }

        stage.addEventListener("pointerenter", (e) => {
          active = true;
          stage.dataset.active = "true";
          // Enable reveal when interaction begins
          funImage.style.setProperty("--r", `${radiusPx}px`);

          setTargetFromEvent(e);
          // Snap current position to target on entry to avoid jump
          cx = tx;
          cy = ty;
          start();
        });

        stage.addEventListener("pointermove", (e) => {
          // Touch/pen don't have hover, so allow drag-to-reveal.
          // Mouse keeps the original hover-to-reveal behavior.
          if (e.pointerType !== "mouse") {
            active = true;
            stage.dataset.active = "true";
          } else {
            if (!active) return;
          }

          setTargetFromEvent(e);
          start();
        });

        stage.addEventListener("pointerleave", () => {
          active = false;
          stage.dataset.active = "false";
          // Hide reveal when leaving
          funImage.style.setProperty("--r", `0px`);

          // Stop animation when not interacting
          if (rafId) {
            cancelAnimationFrame(rafId);
            rafId = null;
          }
        });

        // Touch devices: on tap, toggle active and set position
        stage.addEventListener("pointerdown", (e) => {
          // Only handle touch/pen; mouse already works via hover
          if (e.pointerType === "mouse") return;

          // Keep receiving move events even if the finger drifts slightly off the element.
          try {
            stage.setPointerCapture(e.pointerId);
          } catch (_) {
            // Some browsers may throw if capture isn't allowed; safe to ignore.
          }

          active = true;
          stage.dataset.active = "true";
          // Enable reveal on touch
          funImage.style.setProperty("--r", `${radiusPx}px`);

          setTargetFromEvent(e);
          start();
        });

        stage.addEventListener("pointerup", (e) => {
          if (e.pointerType === "mouse") return;
          active = false;
          stage.dataset.active = "false";
          // Hide reveal on release
          funImage.style.setProperty("--r", `0px`);

          // Stop animating and park lens back to center (keeps it from lingering on mobile)
          const rect = stage.getBoundingClientRect();
          tx = rect.width / 2;
          ty = rect.height / 2;
          cx = tx;
          cy = ty;
          funImage.style.setProperty("--x", `${cx}px`);
          funImage.style.setProperty("--y", `${cy}px`);
          lens.style.left = `${cx}px`;
          lens.style.top = `${cy}px`;

          if (rafId) {
            cancelAnimationFrame(rafId);
            rafId = null;
          }

          try {
            stage.releasePointerCapture(e.pointerId);
          } catch (_) {
            // Ignore
          }
        });

        // Center the mask coordinates on initial load (but keep reveal hidden)
        window.addEventListener("load", () => {
          const rect = stage.getBoundingClientRect();
          tx = cx = rect.width / 2;
          ty = cy = rect.height / 2;
          funImage.style.setProperty("--x", `${cx}px`);
          funImage.style.setProperty("--y", `${cy}px`);
          funImage.style.setProperty("--r", `0px`);
        });
      })();
    </script>
  </body>
</html>
